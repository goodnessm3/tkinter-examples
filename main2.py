from tkinter import *
import random
COLOURS = ["ORANGE", "YELLOW", "GREEN", "BLUE", "CYAN", "MAGENTA"]


def RANDOM_COLOUR():

    """tkinter can understand RGB values like #RRGGBB where the values are hex digits"""

    vals = [hex(random.randint(0, 255)) for _ in range(3)]
    out = "".join([x[2:].zfill(2) for x in vals])
    return f"#{out}"


class LoggingMixIn:

    """provides a method to pass string messages that will then be printed to a logging console registered
    with the custom root window that has a log_message function"""

    _root = None
    # specified so pycharm doesn't complain about unresolved reference, the mixed-in-to class
    # will have this method available

    def log_message(self, message):

        self._root().log_message(message)


class MyRadioButton(Radiobutton):

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)
        self.bind("<Button-1>", lambda x: self.master.event_generate("<<print_radio_var>>"))
        # generate a custom event in the parent when clicked, otherwise just a normal radio button


class MySubFrame(Frame, LoggingMixIn):

    """frame with methods to add widgets to itself"""

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)
        self.config(bg=RANDOM_COLOUR())
        self.bind("<Button-3>", self.on_right_click)
        self.radio_var = IntVar()  # if the user adds radio button widgets, they will use this var
        self.bind("<<print_radio_var>>", lambda x: self.log_message(f"radio var is {self.radio_var.get()}"))
        # custom event generated by child radio buttons

    def on_right_click(self, e):

        popup = Menu(tearoff=0)
        sub_popup = Menu(tearoff=0)
        popup.add_cascade(label="Add widget", menu=sub_popup)
        sub_popup.add_command(label="Checkbox", command=lambda: self.add_widget(Checkbutton))
        sub_popup.add_command(label="Radio button",
                              command=lambda: self.add_widget(MyRadioButton, variable=self.radio_var,
                                                              value=random.randint(0, 100)))
        sub_popup.add_command(label="Colour randomiser",
                              command=lambda: self.add_widget(Button,
                                                              text="random colours",
                                                              command=self._root().randomise_all_colours))
        # a button that calls a method in the root window by getting a reference to root with _root()
        popup.tk_popup(e.x_root, e.y_root, 0)  # make the menu appear where the user clicked

    def add_widget(self, widget_method, **kwargs):

        w = widget_method(self, **kwargs)
        w.pack(side=TOP)
        self.log_message(f"Added a {widget_method}")


class ButtonFrame(Frame, LoggingMixIn):

    """custom frame to contain buttons"""

    def __init__(self, *args, parent_ref=None, **kwargs):

        bg = random.choice(COLOURS)
        # easier to see which frame is which by colouring them
        super().__init__(*args, background=bg, **kwargs)
        self.parent_ref = parent_ref

        for x in range(0, 2):
            b = Button(self, text="Create new\n button")
            b.config(command=self.create_button)
            b.pack(expand=YES, fill=BOTH, pady=5)

    def button_func(self, calling_button):

        old_colour = calling_button["bg"]  # fetch the background colour from the button's dictionary
        self.log_message(f"Button {id(calling_button)} was clicked.")
        calling_button.config(bg=RANDOM_COLOUR())
        self.after(200, lambda: calling_button.config(bg=old_colour))
        # revert the button to its previous colour
        # this "after" call will block if it's not a lambda function

    def create_button(self):

        b = Button(self, text=f"Button {random.randint(0,100)}")
        b.config(command=lambda q=b: self.button_func(q))
        # passing button b as a default argument to the lambda function now
        b.pack(expand=YES, fill=BOTH)
        b.bind("<Button-3>", self.button_rightclick)
        # bind a method to delete the button via a context menu

    def button_rightclick(self, e):

        popup = Menu(tearoff=0)
        popup.add_command(label="Delete", command=lambda x=e: self.delete_button_func(e))
        popup.tk_popup(e.x_root, e.y_root, 0)

    def delete_button_func(self, e):

        e.widget.destroy()
        self.log_message(f"Button {id(e.widget)} was destroyed.")


class LoggingConsole(Text):

    """receives messages from the application root object and displays them."""

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)
        self.register_with_root()
        self.bind("<Button-3>", self.on_rightclick)

    def on_rightclick(self, e):

        popup = Menu(tearoff=0)
        popup.add_command(label="Randomise colour", command=lambda: self.config(bg=RANDOM_COLOUR()))
        popup.tk_popup(e.x_root, e.y_root, 0)

    def log_message(self, message):

        self.insert(END, f"{message}\n")

    def register_with_root(self):

        """place a reference in the root object so it can send messages to this console, everything else can
        communicate to root via _root()"""

        self._root().logging_console = self


class MyRoot(Tk):

    """custom root class with extra functions for the rest of the program to use"""

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)
        self.logging_console = None
        # this is overwritten when the logging console registers itself with the root object
        my_menu = Menu(self)
        actions_menu = Menu(self, tearoff=0)
        self.monitor_menu = Menu(self, tearoff=0)  # need to be able to refer to it later when updating it
        self.config(menu=my_menu)
        my_menu.add_cascade(label="Actions", menu=actions_menu)
        actions_menu.add_command(label="Print to console", command=lambda: self.log_message("from menu"))
        actions_menu.add_command(label="Add sub-frame", command=self.add_sub_frame)
        actions_menu.add_cascade(menu=self.monitor_menu, label="Add monitoring label for...")
        # add_cascade gives a sub-menu with an arrow that can be expanded

        self.monitor_container = Frame(self)
        # set up a container for labels that read out the value of radiobutton variables in sub-frames
        self.monitor_container.pack(side=TOP, fill=BOTH, expand=YES)
        self.monitor_container.config(bg="PINK")
        self.mon_label = Label(self.monitor_container, text="Radio button values:")
        self.mon_label.pack(side=TOP)

    def refresh_monitoring_menu(self):

        """add newly-created sub-frames to the menu for making monitoring labels"""

        self.monitor_menu.delete(0, END)  # clear all entries first

        for child in self.children.values():
            # self.children is a dict that maps a tk path to a python object
            if type(child) is MySubFrame:
                nm = f"Sub frame {id(child)}"
                self.monitor_menu.add_command(label=nm, command=lambda: self.add_monitoring_label(child))

    def randomise_all_colours(self):

        """change background colour of all child widgets"""

        self.log_message("Randomising colours...")
        for child in self.children.values():
            child.config(bg=RANDOM_COLOUR())

    def add_monitoring_label(self, monitored):

        """recieves a reference to the frame it's monitoring, to print the radiobutton variable"""

        con = Frame(self.monitor_container)  # frame to contain the two labels next to each other
        # goes in an area designed for these labels
        la = Label(con, text=f"Radio button value for {id}")
        v = monitored.radio_var
        l2 = Label(con, textvariable=v)
        la.pack(side=LEFT)
        l2.pack(side=LEFT)
        con.pack(side=TOP)

    def add_sub_frame(self):

        """create a new MySubFrame, display it in the root window, and add an option for it in the monitoring menu"""

        pan = MySubFrame(self)
        pan.pack(side=LEFT, expand=YES, fill=BOTH)
        self.refresh_monitoring_menu()  # register new sub-frames in monitoring menu

    def log_message(self, message):

        if self.logging_console:
            self.logging_console.log_message(message)


root = MyRoot()
f1 = Frame(root)
f1.pack(fill=BOTH, expand=YES)
lab = Label(f1, text="test label")
lab.pack()
sub = ButtonFrame(root)
sub.pack(side=LEFT, expand=YES, fill=BOTH)
cons = LoggingConsole(f1)
cons.pack(fill=BOTH, expand=YES)

xdata = [random.randint(0, 100) for _ in range(10)]
ydata = [random.randint(0, 100) for _ in range(10)]

import graph_widget
g1 = graph_widget.MyPieWidget(root, data_series=(["first", "second", "third"], [10, 20, 30]))
g1.pack(side=LEFT)


root.mainloop()
